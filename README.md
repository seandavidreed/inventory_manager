# INVENTORY MANAGER

#### Video Demo: `<url>`

#### Description:

Years ago, I created a simple inventory ordering spreadsheet for my parents' coffee shop. It had a master list of all inventory items that distributed each item to other sheets in the book according to supplier. These sheets could then be attached to an email and sent to each supplier as an order form. It was a clunky system, but it was a great improvement over the paper system it replaced. The Inventory Manager application was designed to improve upon the spreadsheet design. My aim was to closely resemble the spreadsheet system while streamlining the ordering process and adding two new features: order history and analytics.

For this project, I knew that portability was paramount, so I chose to make a web application. I wanted it to be accessible from any device with a browser. For the Web Application Framework, Flask was my initial choice since I had previous experience with it in CS50x. However, I decided on Django for three main reasons. Django comes with a built-in administrative interface for managing the database, it has a robust user authentication and authorization system, and it has greater security. In a nutshell, Django is a "batteries included" WAF, providing features that would have been very difficult for me to develop without a team behind me.

I knew the data I needed to store in a relational database would be simple, so I chose to work with SQLite3. In models.py, I created three models, Supplier, Item, and Order, that would form tables in the database and store all the web app's data. Entries in the Order table are linked via foreign key to entries in the Item table in a One-to-One relationship, and those in the Item table are linked to those in the Supplier table. These relationships allow the app to generate order forms, order history, and item lists based on the scope required. For example, in the ordering process, I needed to organize the Items according to Supplier so only the items they supply would be submitted to them. The Supplier model contains four fields: name, email, send_email, and phone. The app accesses the email field at the end of the take inventory process, sending an order email to each supplier with a send_email value of True. If the value is False, the order form is made available for download as a csv file in the success template. In the Item model, the package and package_qty fields are used together or not at all. They make it possible for an item to be denominated in something larger than one unit. The user can decide what to name the package (e.g. pack, box, case), but ultimately these can all be made to hold the same quantity are are only different from each other in name. Quota is the minimum amount of any given product that must be on hand after restocking has occurred. Storage determines where the unit lives, in the coffee shop  or in the back shed; thus the take inventory list can be separated by storage. Finally, the latest_qty field stores the average order quantity of the last five orders. This value is used to autopopulate the inventory list with values that will be close to what they need.

In views.py, take_inventory displays all the items in the Item table and allows the user to input the quantity they need to order. The order data is first validated to make sure it isn't all zero values and then stored in the session to be accessed later from the finalize view. By storing the order data in the session, the user is given the option to cancel the order right up until they press the submit order button. In finalize, the user is prompted for an optional message to each supplier before submission. Once they submit, an email with the order attached as a PDF is sent to each supplier where send_email is True.  The user is then directed to the success view. Here, the orders of any suppliers where send_email is False can be downloaded as CSVs. Views history, archive, and order all go together. The history view displays the latest 20 orders and an archive button that redirects to the archive view. Here, orders are organized by year for ease of navigation. The order view is accessed by selecting one of the entries in history or archive. The user can see everything that was and was not ordered for that specific order. This is the main purpose of the Order table, to keep an exhaustive record of all units ordered, with zero and non-zero order quantities alike. [Analytics view]

In urls.py, I imported Django's TemplateView class, which allows templates to be served without a corresponding view. I used this class for all the results templates (e.g. empty-order, delete-occurred, no-data) except success, which needed its own view to handle suppliers with a send_email value of False.

[Explain functions.py]

[Go into static folder]

[Explain structure of templates folder]
